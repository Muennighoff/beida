# 学习小结 20210929

#### 尹哲良

## 算法补充

### 快速排序

#### 猴子排序

随机排序，检查是否排好

时间复杂度：
$$
O(n*n!)
$$

#### 基本思想

+ 选择锚点
+ 分成两部分
+ 递归

如果有相同数值怎么办？放在两边或者一起作为锚点

#### 朴素代码实现

```python
def QuickSort(alist):
    if len(alist)<=1:
        return alist
    l=[]
    r=[]
    p=random.randint(0,len(alist)-1)
    pivot=[alist[p]]
    for i in range(len(alist)):
        if i==p:
            continue
        elif alist[i]<p:
            l.append(alist[i])
        else:
            r.append(alist[i])
    return QuickSort(l)+pivot+QuickSort(r)
```

#### 排序算法的分类

比较排序：插入、归并、快排

其他方法：桶排序

#### 复杂度分析

比较排序的决策树有n!个叶子节点，构成的决策树深度最小为nlogn

前提是决策树两边平衡

## 数据结构

### 链表

性质：相比排好序的列表，插入快，查找慢

### 二分查找树

#### 递归定义

左子树的所有节点比根节点小，右子树的所有节点比根节点大

#### 性质

中序遍历得到排序结果

查找复杂度：平衡树O(logn)，极端情况O(n)

#### 实现思路

首先定义 Node 类，然后定义 BinarySearchTree 类，具有插入、删除、遍历功能

#### 节点删除

+ case 1：叶子节点，直接删除
+ case 2：只有一个子节点，将子节点上移
+ case 3：找到右子树的最小节点，代替待删除节点，然后删除右子树的最小节点

### 红黑树

#### 定义

+ 非红即黑
+ 根节点黑
+ 叶节点黑（扩充二叉树的叶节点）
+ 红节点的子节点必须为黑
+ 每条路径上黑节点数目相同

#### 性质

+ 黑节点平衡
+ 红节点分散，不会太过影响平衡性
+ 最长路径不超过最短路径的两倍：高度至多为2*log(n+1)