# Week 3 Summary



## 课程内容大纲
```
快速排序
基本数据结构
	链表与有序数组
	二分查找树 (掌握)
了解红黑树，2-3-4树和B+树
桶排序(Bucket Sort)与哈希结构
```

## 排序 （猴子 和 快速）
> Bogo Sort （猴子排序）
> > 把排序过程交给猴子来干
> > 随机排序，如果是正确排序则返回
> > 执行程序的时间复杂度为O(n)
> > 正确排序的时间复杂度为O(n!*n)
> > 最差结果为无穷大
>
> Quick Sort（快速排序）
> > 理想时间复杂度为O(nlog(n)) (锚点选择刚刚好), 最差为O(n^2)
> > 它和归并排序是一样的
> > 选择一个点（pivot），把小于该点的数字放一起，大于放一起
> > 无限执行直到每组为一个数字
> > 如果一样就放在一起
>
> 比O(nlog(n))更快的算法：
> > StickSort 取巧的算法（筷子一起放在桌子上）
>
> Decision trees （二叉树）
> > 数据复杂度计算：找到最长的节点
> 
> 比较排序类的方法至少需要 nlog(n)

## 二元查找树(Binary Search Trees)
> 数据管理的常用方法（是一种查找的数据结构）
> 红黑树 属于二分查找的一种
> > 优点在于所有的高度会有限制？
> > 
> ## 常见结构：
> > 链表
> > 有序数组（通过index定位位置）
> > 两种方式的不同操作的复杂度不一样，链表插入好（1），有序数组查找好（log（n）），两个删除一样（n）
>
> ## 二元搜索树（binary search tree）（**需要掌握**)
>
> > 在执行 搜索、查找、插入的复杂度都是O(log(n))，这种方法要比链表和有序数组好，是目前最好的结构
> > 最上面是根root，最下面的都是叶子leaves
> > 这主要是用来查找的，所以有一个条件，一个节点的所有左后代都要小于它，右后代都要大于它，满足条件才叫BST
> > 如何查找特定数值？
> > > 和节点对比，小往左，大往右，反复执行直到找到数字，然后返回结果
> > > 如果不存在呢？找到最后只有一个数字，如果不是的话就返回最后一个找到的数字。还可以将该数字插入进入，比最后一个数字大就在它右边，否则在左边
> > 如何删除特定数字呢？
> > 
> > > 找到该数字
> > > > 叶节点：直接删除
> > > > 
> > > > 包含一个叶子的节点：叶子代替，删除原数字
> > > > 
> > > > 如果有多个叶节点：找到刚好比x大一点点的数字，然后替换掉x：右节点的左左左节点，直到最后一个数字，然后拿来替换x
> > > > 
> > > 查找的时间为数组的高度
>

## 红黑树（self-Balancing BST）
> 极端情况每个节点只有有叶子，高度为n
> 
> 如何降低高度？
> > 选择最佳root
> > 但是不是总是可以达到完美平衡的，所以proxy for balance也是可以的
> 
>红黑树实际上指的就是可以自己平衡的树，不用手动平衡
> 
> 五个条件
> > 每个节点都要红或黑
> > 根节点必须是黑的，
> > 最下面的节点也必须是黑的（空的记为NIL），
> > 红节点的孩子也必须是黑的，
> > 从根节点到空节点通过的黑节点数量是相同的
> > 
> 
> 一个红黑色的高度至多为 2log(n)
> 
> 新插入的数字需要是红色的


## 2-3-4 树，桶排序，哈希排法
> 下节课讲