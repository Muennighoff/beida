##第三周
#1  快速排序

**Bogo Sort：**对数列随机排列并检验是否排好序，排好序则break,否则继续循环。复杂度O(n·n!)，最坏情况下永远不会排好序。

**Quick Sort：**选定基准值，将数组分为比基准值小和比基准值大的两部分，对两部分分别排序。复杂度O(nlogn)，但最坏情况下可能是平方级别。

代码如下（随机选取基准值进行比较）

	def qs(A):
    	if len(A) < 1:
        	return A
    	else:
        	L = []
        	R = []
        	p = random.choice(range(len(A)))
        	E = [A[p]]
        	for i in range(A):
            	if i == p:
                	continue
            	if A[i] < A[p]:
                	L.append(A[i])
            	else:
                	R.append(A[i])
        	return qs(L) + E + qs(R) 

**时间复杂度上限问题：**基于比较的排序算法最低的最差情况下的复杂度为nlogn。

该问题等价于求最小的算法对应选择树的深度：考虑到选择树有n!个叶节点，在选择树的叶节点数一定时，平衡树的深度是最小的（平均值原理），深度为log(n!)，也就是nlogn。

#2 二元查找树

**链表：**通过在结点中加入值信息来形成数据结构，每个节点包含有自己的值和下一个节点的地址信息。

[代码](https://gitee.com/zhenchen3419/BDMI-2021A/blob/master/Computing/Algorithm/linked-list.ipynb)

相比数列，链表在插入上的复杂度为O(1)（插入时只需要改变前节点存储的地址信息）,但是寻址的复杂度变为O(n)（需从头遍历链表进行查找）

Q：可否综合数组和链表的优点？

**二元搜索树：**二叉树数据结构，节点
中存有相应的数值，该结点的左子树中的所有节点值均小于该结点，而右子树中的所有节点值均大于该节点

[代码](https://gitee.com/zhenchen3419/BDMI-2021A/blob/master/Computing/Algorithm/BST%E8%AF%BE%E4%B8%8A%E4%B9%A0%E9%A2%98.ipynb)

二元搜索树的查找：根据大小比较沿树深入；插入：先根据大小寻址，然后直接插入；删除：寻址，检查左右子树是否均存在，不均存在的话直接上移存在的子树，否则沿树寻找直接后继值进行重整。在平衡树的情况下，上述操作的复杂度均为logn

Q：如何保持平衡树？

#3 红黑树

**定义：**遵循五个准则

- 节点非红即黑
- 根节点为黑
- 红节点的子节点为黑
- NIL节点为黑
- 任意节点均满足到子树上所有NIL的路径所经黑色节点数目相同

可证明满足上述准则的二叉树最大深度为2log(n+1)