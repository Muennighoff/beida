# <font color=#ad1453>第四周课程小结</font>


## <font color=#1453ad>1. 2-3-4树及B+树</font>

### 1.1 2-3-4树的构造规则
2-3-4树是一种多叉树，其结点可以存进多个数据项，最多有四个子结点和3个数据项，并具有自平衡的性质。其构造规则为：

对于含三个数据项的结点，若将结点中数据按升序编为0，1，2；子结点按升序编为0，1，2，3。则大小关系为：子结点0<数据0<子结点1<数据1<子结点2<数据2<子结点3<数据3<子结点4；除非是叶子结点否则其子节点必须挂满；所有到叶子节点的路径高度相同。

### 1.2查找及插入
对于查找，只需根据子结点与数据的大小关系从根结点开始向下寻找，直到找到为止。

对于插入数据，若要插入的位置不是4结点，则只需将数据放入节点中即可；若插入的位置是4结点，则需对结点进行分裂，分裂的方法为将居中的数据1放入父结点中，较大和较小的数据0、2带着其左右子树分裂为两个2结点。这样做的问题是若待分裂的节点其父节点也是4结点，操作就无法进行，一个解决的方法是在向下寻找插入位置时若在路径中就发现4结点便先行将其分裂，若根节点就是4结点可以在根节点上一级创建一结点作为新的根结点。这样插入时需分裂的4结点其上一级永远不会是4结点。插入节点中分裂的操作实现了2-3-4树的生长及自平衡。

### 1.3红黑树
红黑树可由2-3-4树得来，例如对于3结点，可将其变为上下级两个结点，二者用红色线段连接；对于4结点，可将居中的数据1提出作为父结点，数据0、2带着其子树作为左右两个子结点，数据1与0，2也以红色线段连接。若限定对3结点的分裂，永远将较大的数据1作为父亲结点，数据0作为数据1的左孩子结点，这便构成了左倾的红黑树。

### 1.4B+树
B+树：B+树可视为2-3-4树的拓展。B+树的特点为：中间结点中的数只用来索引，所有的数据保存在叶子结点中；每个叶子结点中都包含了指向下一个叶子结点的指针，则其自身就构成一个有序链表。则B+数不仅可以进行精确查找，也能范围查找。

## <font color=#ad1991>2.桶排序与基排序</font>
### 2.1桶排序
桶排序并非基于比较数据大小的排序方法。其方法为将数组分到有限数量的桶里，每个桶在个别排序，最后依次将各个桶中的数据取出，得到有序数列。例如，对于分布于[m,n]中的整数数列，只需划分编号从m到n的n-m+1个桶，遍历数组，元素的数值为几便将其放入几号桶中，最后按照编号从m到n的顺序依次将桶中的数据取出，则自然得到有序数列。一个问题是这样没办法对既含正数又含负数的数列进行排序，一个方法是可以对所有数加上一个确定的常数，将其全部化为正，排完序后再将常数减去。

### 2.2基数排序
基数排序是桶排序的扩展，基本思想是将一个整数按位数切割为不同的位数，对每个位数分别进行桶排序，这样一直到最高的位数被桶排序完成后，整个数组的排序即告完成。

例如可按进制进行基数排序，将数据转化为m进制，则可划分m个桶。若桶的数目越多，则最高位位数越低，排序的次数越少，排序也越快，但桶的数目越多也越占用空间。基数排序的时间复杂度为O(d(n+r))，其中r为基数，d为最高位位数。

### 2.3程序实现
```python
def radix_sort(arr, base):
    max_ = max(arr)
    len = 1
    a = base
    while a <= max_: #判断最大数的base进制位数
        len += 1
        a = a*base
    for i in range(len):
        buckets = [[] for _ in range(base)]
        for element in arr: #分桶
            radix = int((element/(base**i)) % base)
            buckets[radix].append(element)
        j = 0
        k = 0
        while k <= base-1: #按顺序将桶中的数取回arr
            for num in buckets[k]:
                arr[j] = num
                j += 1
            k += 1
    return arr


array = [12, 42, 74, 87, 1, 60, 32, 10, 94, 11, 18, 93, 51, 28, 2, 33, 98, 56, 1, 34]
radix_sort(array, 16)
print(array)
```
则输出为

[1, 1, 2, 10, 11, 12, 18, 28, 32, 33, 34, 42, 51, 56, 60, 74, 87, 93, 94, 98]

### 2.4时间复杂度的讨论
由于基数排序的时间复杂度为O(d(n+r))，其主要受最大数大小和基数选取的影响，最大数的大小由待处理数据自身的特点决定，我们无法修改，但我们可以根据数组长度以及数据大小等选取合适的基数，基数的选取极大地影响着程序运行的速度。

另外在基数排序内部的运算也可以进行优化：比如对于基数r，其中一步是要取数据在r进制下的各位数，需要用到乘方运算，较为复杂，则乘方可以改由查表的方式获得；或者可以直接以2的幂次作为基数，这样乘除即为移位，取模即为按位与，这样便大大提升了程序运行的速度。

## <font color=#1453ad>3.哈希表与哈希函数</font>
哈希表是根据key value直接对数据进行访问的数据结构。对于待处理的数据，可以构造一种哈希函数，提取出其中的关键字key，之后根据这个函数和查找关键字key就可以直接确定查找值所在的位置：H(key)=数据地址index。

对于一大组数据，我们总希望它们被均匀的放入每一栏里，这样每一栏的数据尽可能少，查找起来所需的时间就少。但对于给定的哈希函数，总会出现有数据大量的集中在某一栏的地址下，这样查找这一栏中的数据就会很费劲。这种问题可以通过合理设计哈希函数的方法尽可能减少哈希冲突的出现，此外还有一些方法来解决哈希冲突。

对于哈希表，其优点为查找极快，最优可以在O(1)时间内查找。但空间需求大，需要O(nlog(M))的空间大小。