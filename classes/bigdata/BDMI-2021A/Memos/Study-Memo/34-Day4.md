# 第四周

## 1 2-3-4树

**基本特征：**一种完全平衡树，每个节点可以有1,2或3个值，将所有值划分为2,3或4个区间，对应有相同数量的子节点。

**搜索：**比较键值和目标数，层层向下寻找，复杂度logn

**插入：**比较键值和目标数，层层向下寻找适合插入的节点，如果对应节点为2-节点，则插入转化为3-节点；对应节点为3-节点，则插入转化为4-节点；如果对应节点为4-节点，则将中间值上移至上一级节点，并将剩余两值分为两个不同的节点，对应的4个子树一同分类，然后再将目标数插入其中一个节点。

![](https://thu-private-qn.yuketang.cn/slide/212726/163349942118701FHA2E6G3BPHM0JJSHDJH4R2H?e=1633703264&token=IAM-gs8ue1pDIGwtR1CR0Zjdagg7Q2tn5G_1BqTmhmqa:nhgG6p3I4-PA3Vu083P9r3Wqcj0=)

**LLRB树：**对于2-3-4树的3-节点，我们将其分裂为原节点和一个在左的子节点，并用红色路径连接；对于2-3-4树的4-节点，我们将其分裂为原节点（中间值）和两个子节点，并用红色路径连接子节点与原节点，得到了LLRB树。易知2-3-4树可以实现与LLRB树的一一对应。

相比2-3-4树，LLRB树通过二叉树的方式进行构建，没有复杂的节点结构，可以直接应用二叉树的算法。

## 2 B+树

**基本特征：**一种n叉排序树，每个内部节点通过n个值将所有值划分为n+1个区间并拥有对应的子节点，每个叶节点都位于同一层且包含不多于2d且不少于d个元素，这些元素中的最后一个是指向下一个叶节点的指针。

**搜索与更新：**与其他的树结构相同，从根节点开始向下比较查找，同样的方法也可以应用于范围查找，同理也可以进行数据的更新。

## 3 桶排序与基数排序

**桶排序：**对于一个元素范围在[a,b)的数组，构造b-a个桶，遍历数组，将值为k的元素装入编号为k-a的桶中，最后在遍历各个桶取出元素即得排好序的数组。

复杂度为O（n）

    def bs(A, min, max):
    	buckets = [[] for _ in range(min, max + 1)]
    	for x in A:
        	buckets[x].append(x)
    	sorted_arr = []
    	for bucket in buckets:
        	for x in bucket:
            	sorted_arr.append(x)
    	return sorted_arr

**基数排序：**采用多次桶排序的方法减少桶的用量。先依据个位进行桶排序，再依据十位进行桶排序，逐次进行下去。

复杂度为O（nd），d为位数

在采取更高的进制时，可以减少d的大小，同时增加空间代价和桶构建的时间代价，复杂度为O（d(n+r)），r为进制数

## 4 哈希

基于桶排序的思想，试图将数据以桶和数值的方式进行组织，每个桶中尽可能只存有一个数据，多个数据时以链表避免冲突。

其中最主要的问题是建立目标数据和桶的标号间的映射——哈希函数与哈希表

对于任一确定的的哈希函数，**总有一些数据会被映射到同一值**，当目标数据均为该类数据时就会出现最坏的情况——相比原来没有任何优化。为了避免这类情况，我们采取**随机**哈希的方式。

如果采用完全随机的映射方式（哈希函数总量为n的m次幂），可以证明满足我们的期望（E（x）<2），但是存储这类哈希函数有需要**额外的空间与时间代价**（需要记录所有自变量对应的值）。

新策略：缩小随机范围，取原有的全体函数的子集`H={h(x)=ax+b丨a∈{1,2，...,p-1}，b∈{1,2，...,p-1}}`,同样可以证明满足我们的期望，而且对于任何一个哈希函数，只需要存储两个值，空间和时间代价几乎为零。



